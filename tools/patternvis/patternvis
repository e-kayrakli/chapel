#! /bin/env python
import sys
import argparse
import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from log_parser import LocaleLog, MetaLog

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('filename')
arg_parser.add_argument('--only-locale')
arg_parser.add_argument('--no-local-subdomains', action='store_true')

args = arg_parser.parse_args()
only_locale = args.only_locale
no_local_subdomains = args.no_local_subdomains
filename = args.filename
dirname = '__aal/'+filename
meta_log_name= dirname+'/'+filename+'meta'
locale_log_prefix = dirname+'/'+filename+'locale_'

# We just subclass Rectangle so that it can be called with an Axes
# instance, causing the rectangle to update its shape to match the
# bounds of the Axes
# class UpdatingRect(Rectangle):
    # def __call__(self, ax):
        # self.set_bounds(*ax.viewLim.bounds)
        # ax.figure.canvas.draw_idle()

# FIXME get rid of this by figuring out where the padding comes from
pad_comp = 0.5
size_comp = 0.5

def inc_color(cur, inc):
    return (cur[0], cur[1]-inc, cur[2]-inc)

# A class that will regenerate a fractal set as we zoom in, so that you
# can actually see the increasing detail.  A box in the left panel will show
# the area to which we are zoomed.
class Display(object):
    def __init__(self, filename, rank, h=1000, w=1000):
        self.filename = filename
        self.__ll = LocaleLog(filename, rank)

        self.rank = self.__ll.rank
        self.whole_lims = self.__ll.whole_lims
        self.subdom_lims = self.__ll.subdom_lims
        self.access_mat = self.__ll.access_mat
        self.max_access = self.__ll.max_access

        self.height = h
        self.width = w

        self.d1_offset = self.whole_lims[0][0]
        if self.rank == 2:
            self.d2_offset = self.whole_lims[1][0]

        self.tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    def get_locsubdom_rect(self):
        for sdl in self.subdom_lims:
            subdom_rank = len(sdl)
            x = sdl[0][0] - pad_comp
            width = sdl[0][1] - x + 1 - size_comp

            if subdom_rank == 1:
                x -= self.d1_offset
            else:
                x -= self.d2_offset

            if subdom_rank == 2:
                y = sdl[1][0] - pad_comp
                height = sdl[1][1] - y + 1 - size_comp
                y -= self.d1_offset
            else: # rank == 1
                y = 0
                height = self.height


            x *= self.ratio
            y *= self.ratio
            width *= self.ratio
            height *= self.ratio

            yield Rectangle((x,y), width, height, fill=False,
                    color='green', hatch='///')

    def get_image(self):

        # self.x = np.linspace(xstart, xend, self.width)
        # self.y = np.linspace(ystart, yend, self.height)

        access_mat_d1_size = len(self.access_mat)
        access_mat_d2_size = len(self.access_mat[0])
        if self.rank == 1:
            if access_mat_d1_size < self.width:
                # find the nearest multiple to 500
                rem = self.width%access_mat_d1_size;
                self.width -= rem
                self.height = 25
                self.ratio = int(self.width/access_mat_d1_size)
                binning=False
                scaleup=True
            else:
                print("Not ready for this yet")

        elif self.rank == 2:
            if access_mat_d1_size == access_mat_d2_size:
                if access_mat_d1_size < self.height:
                    # good we are going to scale-up access data onto image

                    # find the nearest multiple to 500
                    rem = self.height%access_mat_d1_size;
                    self.height -= rem
                    self.width = self.height
                    self.ratio = int(self.height/access_mat_d1_size)
                    binning=False
                    scaleup=True
                else:
                    # data is larger than the image we'll do binning
                    binning=True
                    scaleup=False
                    ratio = access_mat_d1_size/self.height

        self.x = np.linspace(0, self.width-1, self.width)
        self.y = np.linspace(0, self.height-1, self.height)


        image = [[(1.0, 1.0, 1.0) for x in range(self.width)] for y in
            range(self.height)]

        per_access_delta = 1.0/self.max_access

        r = self.ratio
        for row in range(access_mat_d1_size):
            for col in range(access_mat_d2_size):
                access_count = self.access_mat[row][col]
                if access_count > 0:
                    for i in range(row*r, (row+1)*r):
                        if self.rank == 1:
                            for j in range(self.height):
                                image[j][i] = inc_color(image[j][i],
                                        per_access_delta*access_count)
                        if self.rank == 2:
                            for j in range(col*r, (col+1)*r):
                                # if image[i][j] == (1.0, 1.0, 1.0):
                                    # image[i][j] = (0.0, 1.0, 0.0)
                                image[i][j] = inc_color(image[i][j],
                                        per_access_delta*access_count)
        

        return image
    
    def get_ticks(self, axis):
        if axis == 'x':
            return [self.x.max()*r for r in self.tick_locs]
        elif axis == 'y':
            if self.rank == 1:
                return []
            elif self.rank == 2:
                return [self.y.max()*r for r in self.tick_locs]


    def get_tick_labels(self, axis):
        if axis == 'x':
            if self.rank == 1:
                return [int(len(self.access_mat)*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 
            elif self.rank == 2:
                return [int(len(self.access_mat[0])*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 
        if axis == 'y':
            if self.rank == 1:
                return []
            elif self.rank == 2:
                return [int(len(self.access_mat)*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 

def do_plot(i, a, rank):
    d = Display(filename=locale_log_prefix+str(i), rank=rank)
    Z = d.get_image()
    
    img_shape = (d.x.min(), d.x.max(),
        d.y.min(), d.y.max())

    a.set_xlim(0.0, d.x.max());
    a.set_ylim(0., d.y.max());

    # a.imshow(Z, origin='lower', extent=img_shape)
    a.imshow(Z, origin='lower')
    if not no_local_subdomains:
        for r in d.get_locsubdom_rect():
            a.add_patch(r)
    a.set_ylim(a.get_ylim()[::-1])
    a.set_xticks(d.get_ticks('x'))
    a.set_yticks(d.get_ticks('y'))
    a.set_xticklabels(d.get_tick_labels('x'), fontsize=8)
    a.set_yticklabels(d.get_tick_labels('y'), fontsize=8)
    a.grid(linestyle='dotted')

def plot():
    metalog_handler = MetaLog(meta_log_name)
    target_loc_shape = metalog_handler.target_loc_shape
    rank = len(target_loc_shape)
    num_locs = 1
    for t in target_loc_shape:
        num_locs *= t

    if rank == 1:
        plot_dist = (target_loc_shape[0], 1)
    elif rank == 2:
        plot_dist = target_loc_shape

    # tick_locs = [0., 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.]
    # TODO parametrize this
    # tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    if only_locale != None:
        fig1, ax = plt.subplots(1,1)
        do_plot(only_locale, ax, rank)
    else:
        fig1, axes = plt.subplots(plot_dist[0], plot_dist[1])
        for i,(idx,a) in zip(range(num_locs), np.ndenumerate(axes)):
            do_plot(i, a, rank)

    plt.margins(0,0)
    plt.show()

if __name__=="__main__":
    plot()
