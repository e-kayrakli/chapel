#! /bin/env python
import sys
import argparse
import math
import numpy as np
import matplotlib.pyplot as plt
import itertools as it
from matplotlib.patches import Rectangle
from log_parser import LocaleLog, MetaLog

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('filename')
arg_parser.add_argument('--only-locale', type=int)
arg_parser.add_argument('--no-local-subdomains', action='store_true')
arg_parser.add_argument('--no-pwise-access', action='store_true')
arg_parser.add_argument('--plot', action='store_true')
arg_parser.add_argument('--no-analysis', action='store_true')

args = arg_parser.parse_args()
only_locale = args.only_locale
no_local_subdomains = args.no_local_subdomains
no_pwise_access = args.no_pwise_access
filename = args.filename
dirname = '__aal/'+filename
meta_log_name= dirname+'/'+filename+'meta'
locale_log_prefix = dirname+'/'+filename+'locale_'
plot = args.plot
analysis = not args.no_analysis

# We just subclass Rectangle so that it can be called with an Axes
# instance, causing the rectangle to update its shape to match the
# bounds of the Axes
# class UpdatingRect(Rectangle):
    # def __call__(self, ax):
        # self.set_bounds(*ax.viewLim.bounds)
        # ax.figure.canvas.draw_idle()

# FIXME get rid of this by figuring out where the padding comes from
pad_comp = 0.
size_comp = 0.

def inc_color(cur, inc):
    return (cur[0], cur[1]-inc, cur[2]-inc)

# A class that will regenerate a fractal set as we zoom in, so that you
# can actually see the increasing detail.  A box in the left panel will show
# the area to which we are zoomed.
class Display(object):
    def __init__(self, locale_log, lid, h=1000, w=1000):
        self.__ll = locale_log
        self.lid = lid

        self.rank = self.__ll.rank
        self.whole = self.__ll.whole
        self.subdoms = self.__ll.subdoms
        self.access_mat = self.__ll.access_mat
        self.max_access = self.__ll.max_access

        self.height = h
        self.width = w

        self.d1_offset = self.whole[0].low
        if self.rank == 2:
            self.d2_offset = self.whole[1].low

        self.tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    def get_pwise_access_bbox_rect(self, remote_only=True):
        for (i,ab) in enumerate(self.__ll.pwise_bboxes):
            if remote_only and i == self.lid:
                continue
            r = self.gen_rectangle_from_dom(ab)[0]
            r.set_fill(True)
            r.set_color('blue')
            # r.set_hatch('\\\\\\')
            r.set_alpha(0.7)
            yield r

    def get_locsubdom_rect(self):
        for sd in self.subdoms:
            rs = self.gen_rectangle_from_dom(sd)
            for r in rs:
                r.set_fill(True)
                r.set_color('green')
                r.set_alpha(0.7)
                # r.set_hatch('///')
                yield r


    def gen_rectangle_from_dom(self, dom):
        assert dom.strided and dom.rank == 1 or not dom.strided
        subdom_rank = dom.rank
        x = dom[0].low - pad_comp

        # FIXME what happens if dom is 2d and strided?
        if not dom.strided:
            width = dom[0].high - dom[0].low + 1 - size_comp
        else:
            width = 1

        if subdom_rank == 1:
            x -= self.d1_offset
        else:
            x -= self.d2_offset

        if subdom_rank == 2:
            y = dom[1].low - pad_comp
            height = dom[1].high - y + 1 - size_comp
            y -= self.d1_offset
        else: # rank == 1
            y = 0
            height = self.height

        x *= self.ratio
        y *= self.ratio
        width *= self.ratio
        height *= self.ratio

        if not dom.strided:
            return [Rectangle((x,y), width, height), ]
        else:
            up_lim = int(dom[0].high*self.ratio)
            stride = int(dom[0].stride*self.ratio)
            print('rat', self.ratio)
            print('upper', up_lim)
            print('stride', stride)
            print('width', width)
            print('start', math.ceil(x))

            return [Rectangle((x+off,y),width,height)
                    for off in range(0, up_lim+1, stride)]

    def get_image(self):

        def largest_mul_smaller_then(num, limit):
            # an ugly helper
            for off in range(0, limit):
                div = num/(limit-off)
                if int(div) == div:
                    return limit-off

        def normalize_image(image):
            h = len(image)
            w = len(image[0])


            largest = 0
            for i,j in it.product(range(h), range(w)):
                if image[i][j][2] > largest:
                    largest = image[i][j][2]
            
            for i,j in it.product(range(h), range(w)):
                image[i][j] = (1.0,
                              image[i][j][1]/largest,
                              image[i][j][2]/largest)

            return image


        # self.x = np.linspace(xstart, xend, self.width)
        # self.y = np.linspace(ystart, yend, self.height)

        access_mat_d1_size = len(self.access_mat)
        access_mat_d2_size = len(self.access_mat[0])
        if self.rank == 1:
            if access_mat_d1_size < self.width:
                # find the nearest multiple to 500
                rem = self.width%access_mat_d1_size;
                self.width -= rem
                self.height = 25
                self.ratio = int(self.width/access_mat_d1_size)
                binning=False
                scaleup=True
            else:

                # wrong logic!!
                # we need to find the largest number that is smaller
                # then width and divides access_mat_d1_size
                
                # rem = access_mat_d1_size%self.width
                self.width = largest_mul_smaller_then(
                                    access_mat_d1_size,
                                    self.width)
                self.height = 25
                self.ratio = int(access_mat_d1_size/self.width)

                binning=True
                scaleup=False

                # print("Not ready for this yet")

        elif self.rank == 2:
            if access_mat_d1_size == access_mat_d2_size:
                if access_mat_d1_size < self.height:
                    # good we are going to scale-up access data onto image

                    # find the nearest multiple to 500
                    rem = self.height%access_mat_d1_size;
                    self.height -= rem
                    self.width = self.height
                    self.ratio = int(self.height/access_mat_d1_size)
                    binning=False
                    scaleup=True
                else:
                    # data is larger than the image we'll do binning
                    binning=True
                    scaleup=False
                    ratio = access_mat_d1_size/self.height

        self.x = np.linspace(0, self.width-1, self.width)
        self.y = np.linspace(0, self.height-1, self.height)



        r = self.ratio
        if scaleup and not binning:
            image = [[(1.0, 1.0, 1.0) for x in range(self.width)]
                                      for y in range(self.height)]

            per_access_delta = 1.0/self.max_access
            for row in range(access_mat_d1_size):
                for col in range(access_mat_d2_size):
                    access_count = self.access_mat[row][col]
                    if access_count > 0:
                        for i in range(row*r, (row+1)*r):
                            if self.rank == 1:
                                for j in range(self.height):
                                    image[j][i] = inc_color(image[j][i],
                                            per_access_delta*access_count)
                            if self.rank == 2:
                                for j in range(col*r, (col+1)*r):
                                    # if image[i][j] == (1.0, 1.0, 1.0):
                                        # image[i][j] = (0.0, 1.0, 0.0)
                                    image[i][j] = inc_color(image[i][j],
                                            per_access_delta*access_count)
        
        elif binning and not scaleup:
            image = [[(0.0, 0.0, 0.0) for x in range(self.width)]
                                      for y in range(self.height)]

            for row in range(access_mat_d1_size):
                for col in range(access_mat_d2_size):
                    access_count = self.access_mat[row][col]
                    if access_count > 0:
                        if self.rank == 1:
                            i = int(row/self.ratio)
                            print('width: ', self.width)
                            print(i)
                            for j in range(self.height):
                                image[j][i] = inc_color(image[j][i],
                                                    -access_count)

                        elif self.rank == 2:
                            print('Not ready')

            image = normalize_image(image)

        else:
            print('Unknown config')


        return image
    
    def get_ticks(self, axis):
        if axis == 'x':
            return [self.x.max()*r for r in self.tick_locs]
        elif axis == 'y':
            if self.rank == 1:
                return []
            elif self.rank == 2:
                return [self.y.max()*r for r in self.tick_locs]


    def get_tick_labels(self, axis):
        if axis == 'x':
            if self.rank == 1:
                return [int(len(self.access_mat)*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 
            elif self.rank == 2:
                return [int(len(self.access_mat[0])*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 
        if axis == 'y':
            if self.rank == 1:
                return []
            elif self.rank == 2:
                return [int(len(self.access_mat)*r) 
                        for r in [0., 0.25, 0.5, 0.75, 1.]] 

# TODO s/a/ax
def gen_plot(a, locale_log, lid):
    d = Display(locale_log, lid)
    Z = d.get_image()
    
    img_shape = (d.x.min(), d.x.max(),
        d.y.min(), d.y.max())

    a.set_xlim(0.0, d.x.max());
    a.set_ylim(0., d.y.max());

    # a.imshow(Z, origin='lower', extent=img_shape)
    a.imshow(Z, origin='lower')
    if not no_local_subdomains:
        for r in d.get_locsubdom_rect():
            a.add_patch(r)
    if not no_pwise_access:
        for r in d.get_pwise_access_bbox_rect():
            a.add_patch(r)
    a.set_ylim(a.get_ylim()[::-1])
    a.set_xticks(d.get_ticks('x'))
    a.set_yticks(d.get_ticks('y'))
    a.set_xticklabels(d.get_tick_labels('x'), fontsize=8)
    a.set_yticklabels(d.get_tick_labels('y'), fontsize=8)
    a.grid(linestyle='dotted')

def do_plot(metalog_handler, ll_handlers):
    # metalog_handler = MetaLog(meta_log_name)
    target_loc_shape = metalog_handler.target_loc_shape
    rank = len(target_loc_shape)
    num_locs = 1
    for t in target_loc_shape:
        num_locs *= t

    if rank == 1:
        plot_dist = (target_loc_shape[0], 1)
    elif rank == 2:
        plot_dist = target_loc_shape

    # tick_locs = [0., 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.]
    # TODO parametrize this
    # tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    if only_locale != None:
        fig1, ax = plt.subplots(1,1)
        gen_plot(ax, ll_handlers[only_locale], only_locale)
    else:
        fig1, axes = plt.subplots(plot_dist[0], plot_dist[1])
        # TODO maybe change the order of the iterands
        for llh,(idx,a) in zip(ll_handlers, np.ndenumerate(axes)):
            gen_plot(a, llh, idx)

    plt.margins(0,0)
    plt.show()

def init_log_handlers():
    metalog_handler = MetaLog(meta_log_name)

    target_loc_shape = metalog_handler.target_loc_shape
    rank = len(target_loc_shape)
    num_locs = 1
    for t in target_loc_shape:
        num_locs *= t

    lls = []
    for i in range(num_locs):
        lls.append(LocaleLog(filename=locale_log_prefix+str(i),
                             rank=metalog_handler.rank))

    return (metalog_handler, lls)

def rar(llhs):
    print('Remote access ratios')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_rar()))

def access_bbox(llhs):
    print('Overall access box')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_bbox()))

def pairwise_access_bbox(llhs):
    print('Pairwise access box')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}'.format(i))
        for (j,bb) in enumerate(ll.gen_pairwise_access_bbox(llhs)):
            print('\tLOCALE{}\t\t{}'.format(j, str(bb)))

def access_mem_ratio(llhs):
    print('Access memory ratios')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_mem_ratio()))

def access_bbox_efficiency(llhs):
    print('Access bbox efficiency')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_bbox_efficiency()))

def main():
    mlh, llhs = init_log_handlers()
    if analysis:
        access_bbox_efficiency(llhs)
        access_mem_ratio(llhs)
        rar(llhs)
        access_bbox(llhs)
        pairwise_access_bbox(llhs)
    if plot:
        do_plot(mlh, llhs)

if __name__=="__main__":
    main()
