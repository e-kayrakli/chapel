#! /bin/env python
import sys
import argparse
import math
import numpy as np
import matplotlib.pyplot as plt
import itertools as it
from matplotlib.patches import Rectangle
from log_parser import LocaleLog, MetaLog

arg_parser = argparse.ArgumentParser()
arg_parser.add_argument('filename')
arg_parser.add_argument('--only-locale', type=int)
arg_parser.add_argument('--no-local-subdomains', action='store_true')
arg_parser.add_argument('--no-pwise-access', action='store_true')
arg_parser.add_argument('--plot', action='store_true')
arg_parser.add_argument('--no-analysis', action='store_true')

args = arg_parser.parse_args()
only_locale = args.only_locale
no_local_subdomains = args.no_local_subdomains
no_pwise_access = args.no_pwise_access
filename = args.filename
dirname = '__aal/'+filename
meta_log_name= dirname+'/'+filename+'meta'
locale_log_prefix = dirname+'/'+filename+'locale_'
plot = args.plot
analysis = not args.no_analysis

# We just subclass Rectangle so that it can be called with an Axes
# instance, causing the rectangle to update its shape to match the
# bounds of the Axes
# class UpdatingRect(Rectangle):
    # def __call__(self, ax):
        # self.set_bounds(*ax.viewLim.bounds)
        # ax.figure.canvas.draw_idle()

# FIXME get rid of this by figuring out where the padding comes from
pad_comp = 0.
size_comp = 0.

def inc_color(cur, inc):
    return (cur[0], cur[1]-inc, cur[2]-inc)

# A class that will regenerate a fractal set as we zoom in, so that you
# can actually see the increasing detail.  A box in the left panel will show
# the area to which we are zoomed.
class Display(object):
    def __init__(self, locale_log, lid, h=1000, w=1331):
        self.__ll = locale_log
        self.lid = lid

        self.rank = self.__ll.rank
        self.whole = self.__ll.whole
        self.subdoms = self.__ll.subdoms
        self.access_mat = self.__ll.access_mat
        self.max_access = self.__ll.max_access

        self.height = h
        self.width = w

        self.d1_offset = self.whole[0].low
        if self.rank == 2:
            self.d2_offset = self.whole[1].low

        self.tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    def get_pwise_access_bbox_rect(self, remote_only=True):
        for (i,ab) in enumerate(self.__ll.pwise_bboxes):
            if remote_only and i == self.lid:
                continue
            r = self.gen_rectangle_from_dom(ab)[0]
            r.set_fill(True)
            r.set_color('blue')
            # r.set_hatch('\\\\\\')
            r.set_alpha(0.7)
            yield r

    def get_locsubdom_rect(self):
        for sd in self.subdoms:
            rs = self.gen_rectangle_from_dom(sd)
            for r in rs:
                r.set_fill(True)
                r.set_color('green')
                r.set_alpha(0.7)
                # r.set_hatch('///')
                yield r


    def gen_rectangle_from_dom(self, dom):
        assert dom.strided and dom.rank == 1 or not dom.strided
        subdom_rank = dom.rank
        x = dom[0].low - pad_comp

        # FIXME what happens if dom is 2d and strided?
        if not dom.strided:
            width = dom[0].high - dom[0].low + 1 - size_comp
        else:
            width = 1

        if subdom_rank == 1:
            x -= self.d1_offset
        else:
            x -= self.d2_offset

        if subdom_rank == 2:
            y = dom[1].low - pad_comp
            height = dom[1].high - y + 1 - size_comp
            y -= self.d1_offset
        else: # rank == 1
            y = 0
            height = self.height

        x *= self.ratio
        y *= self.ratio
        width *= self.ratio
        height *= self.ratio

        if not dom.strided:
            if subdom_rank == 1:
                return [Rectangle((x,y), width, height), ]
            else:
                return [Rectangle((y,x), height, width), ]
        else:
            up_lim = int(dom[0].high*self.ratio)
            stride = int(dom[0].stride*self.ratio)
            print('rat', self.ratio)
            print('upper', up_lim)
            print('stride', stride)
            print('width', width)
            print('start', math.ceil(x))

            return [Rectangle((x+off,y),width,height)
                    for off in range(0, up_lim+1, stride)]

    def get_image(self):

        def largest_mul_smaller_then(num, limit):
            # an ugly helper
            for off in range(0, limit):
                div = num/(limit-off)
                if int(div) == div:
                    return limit-off

        def normalize_image(image):
            h = len(image)
            w = len(image[0])


            largest = 0
            for i,j in it.product(range(h), range(w)):
                if image[i][j][2] > largest:
                    largest = image[i][j][2]
            
            for i,j in it.product(range(h), range(w)):
                image[i][j] = (1.0,
                              image[i][j][1]/largest,
                              image[i][j][2]/largest)

            return image


        # self.x = np.linspace(xstart, xend, self.width)
        # self.y = np.linspace(ystart, yend, self.height)

        am_ndim = self.access_mat.ndim
        assert am_ndim < 3
        am_shape = self.access_mat.shape

        access_mat_d1_size = am_shape[0]
        access_mat_d2_size = 1 if am_ndim==1 else am_shape[1]
        if self.rank == 1:
            if access_mat_d1_size <= self.width:
                # find the nearest multiple to 500
                rem = self.width%access_mat_d1_size;
                self.width -= rem
                self.height = 25
                self.ratio = int(self.width/access_mat_d1_size)
                binning=False
                scaleup=True
            else:

                self.width = largest_mul_smaller_then(
                                    access_mat_d1_size,
                                    self.width)
                self.height = 25
                self.ratio = int(access_mat_d1_size/self.width)

                binning=True
                scaleup=False

                # print("Not ready for this yet")

        elif self.rank == 2:
            if access_mat_d1_size == access_mat_d2_size:
                if access_mat_d1_size < self.height:
                    # good we are going to scale-up access data onto image

                    # find the nearest multiple to 500
                    rem = self.height%access_mat_d1_size;
                    self.height -= rem
                    self.width = self.height
                    self.ratio = int(self.height/access_mat_d1_size)
                    binning=False
                    scaleup=True
                else:
                    # data is larger than the image we'll do binning
                    binning=True
                    scaleup=False
                    ratio = access_mat_d1_size/self.height

        self.x = np.linspace(0, self.width-1, self.width)
        self.y = np.linspace(0, self.height-1, self.height)



        r = self.ratio
        if scaleup and not binning:
            image = [[(1.0, 1.0, 1.0) for x in range(self.width)]
                                      for y in range(self.height)]

            per_access_delta = 1.0/self.max_access
            for idx, acc_cnt in np.ndenumerate(self.access_mat):
                if acc_cnt > 0:
                    for i in range(idx[0]*r, (idx[0]+1)*r):
                        if self.rank == 1:
                            for j in range(self.height):
                                image[j][i] = inc_color(image[j][i],
                                        per_access_delta*acc_cnt)
                        if self.rank == 2:
                            for j in range(idx[1]*r, (idx[1]+1)*r):
                                # if image[i][j] == (1.0, 1.0, 1.0):
                                    # image[i][j] = (0.0, 1.0, 0.0)
                                image[i][j] = inc_color(image[i][j],
                                        per_access_delta*acc_cnt)
        
        elif binning and not scaleup:
            image = [[(0.0, 0.0, 0.0) for x in range(self.width)]
                                      for y in range(self.height)]

            for idx, acc_cnt in np.ndenumerate(self.access_mat):
                    if acc_cnt > 0:
                        if self.rank == 1:
                            i = int(idx[0]/self.ratio)
                            for j in range(self.height):
                                image[j][i] = inc_color(image[j][i],
                                                        -acc_cnt)

                        elif self.rank == 2:
                            print('Not ready')

            image = normalize_image(image)

        else:
            print('Unknown config')


        return image
    
    def get_ticks(self, axis, viewlims=None):
        if viewlims is None:
            if axis == 'x':
                return [self.x.max()*r for r in self.tick_locs]
            elif axis == 'y':
                if self.rank == 1:
                    return []
                elif self.rank == 2:
                    return [self.y.max()*r for r in self.tick_locs]
        else:
            lo = viewlims[0]
            hi = viewlims[1]
            if axis == 'x':
                lo_ratio = lo/self.width
                hi_ratio = hi/self.width
                start = self.x.max()*lo_ratio
                dist = self.x.max()*(hi_ratio-lo_ratio)
                return [start+dist*r for r in self.tick_locs]
                
    def get_tick_labels(self, axis, viewlims=None):
        am_shape = self.access_mat.shape
        if viewlims is None:
            if axis == 'x':
                if self.rank == 1:
                    return [int(am_shape[0]*r) 
                            for r in [0., 0.25, 0.5, 0.75, 1.]] 
                elif self.rank == 2:
                    return [int(am_shape[1]*r) 
                            for r in [0., 0.25, 0.5, 0.75, 1.]] 
            if axis == 'y':
                if self.rank == 1:
                    return []
                elif self.rank == 2:
                    return [int(am_shape[0]*r) 
                            for r in [0., 0.25, 0.5, 0.75, 1.]] 
        else:
            lo = viewlims[0]
            hi = viewlims[1]
            if axis == 'x':
                lo_ratio = lo/self.width
                hi_ratio = hi/self.width
                start = am_shape[0]*lo_ratio
                dist = am_shape[0]*(hi_ratio-lo_ratio)
                return[int(start+dist*r) for r in self.tick_locs]


d = None
# TODO s/a/ax
def gen_plot(a, locale_log, lid):
    global d
    d = Display(locale_log, lid)
    Z = d.get_image()
    
    img_shape = (d.x.min(), d.x.max(),
        d.y.min(), d.y.max())

    a.set_xlim(0.0, d.x.max());
    a.set_ylim(0., d.y.max());

    # a.imshow(Z, origin='lower', extent=img_shape)
    a.imshow(Z, origin='lower')
    if not no_local_subdomains:
        for r in d.get_locsubdom_rect():
            a.add_patch(r)
    if not no_pwise_access:
        for r in d.get_pwise_access_bbox_rect():
            a.add_patch(r)
    a.set_ylim(a.get_ylim()[::-1])
    a.set_xticks(d.get_ticks('x'))
    a.set_yticks(d.get_ticks('y'))
    a.set_xticklabels(d.get_tick_labels('x'), fontsize=8)
    a.set_yticklabels(d.get_tick_labels('y'), fontsize=8)
    a.grid(linestyle='dotted')

def do_plot(metalog_handler, ll_handlers):
    # metalog_handler = MetaLog(meta_log_name)
    target_loc_shape = metalog_handler.target_loc_shape
    rank = len(target_loc_shape)
    num_locs = 1
    for t in target_loc_shape:
        num_locs *= t

    if rank == 1:
        plot_dist = (target_loc_shape[0], 1)
    elif rank == 2:
        plot_dist = target_loc_shape

    # tick_locs = [0., 0.125, 0.25, 0.375, 0.5, 0.625, 0.75, 0.875, 1.]
    # TODO parametrize this
    # tick_locs = [0., 0.25, 0.5, 0.75, 1.]

    if only_locale != None:
        fig1, ax = plt.subplots(1,1)
        gen_plot(ax, ll_handlers[only_locale], only_locale)
    else:
        fig1, axes = plt.subplots(plot_dist[0], plot_dist[1])
        # TODO maybe change the order of the iterands
        for llh,(idx,a) in zip(ll_handlers, np.ndenumerate(axes)):
            gen_plot(a, llh, idx)

    # plt.figsize=(8,8)
    # ax.set_aspect('equal', adjustable='box', anchor='C')

    def on_key(event):
        if event.key == 'ctrl+d':
            print('you pressed', event.key, event.xdata, event.ydata)

    def on_resize(event):
        print('you resized')
        ax.set_autoscale_on(False)  # Otherwise, infinite loop

        # Get the number of points from the number of
        # pixels in the window
        # dims = ax.axesPatch.get_window_extent().bounds
        lim = ax.viewLim
        # print(ax.images[0].get_extent())
        # print('bottom left: ', (lim.x0, lim.y0),
              # 'top right: ',   (lim.x1, lim.y1))
        xlims = (lim.x0, lim.x1)
        ax.set_xticks(d.get_ticks('x', viewlims=xlims))
        ax.set_xticklabels(d.get_tick_labels('x', viewlims=xlims))

    # cid = ax.mpl_connect('resize_event', on_resize)
    # ax.callbacks.connect('xlim_changed', on_resize)
    # ax.callbacks.connect('ylim_changed', on_resize)

    plt.margins(0,0)
    plt.show()

def init_log_handlers():
    metalog_handler = MetaLog(meta_log_name)

    target_loc_shape = metalog_handler.target_loc_shape
    rank = len(target_loc_shape)
    num_locs = 1
    for t in target_loc_shape:
        num_locs *= t

    lls = []
    for i in range(num_locs):
        lls.append(LocaleLog(filename=locale_log_prefix+str(i),
                             rank=metalog_handler.rank))

    return (metalog_handler, lls)

def total_access(llhs):
    print('Total number of accesses')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_total_access()))

def rar(llhs):
    print('Remote access ratios')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_rar()))

def access_bbox(llhs):
    print('Overall access box')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_bbox()))

def pairwise_access_bbox(llhs):
    print('Pairwise access box')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}'.format(i))
        for (j,bb) in enumerate(ll.gen_pairwise_access_bbox(llhs)):
            print('\tLOCALE{}\t\t{}'.format(j, str(bb)))

def pwise_access_efficiency(llhs):
    print('Pairwise access box efficiency')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}'.format(i))
        for (j,bb) in enumerate(ll.gen_pwise_access_efficiency(llhs)):
            print('\tLOCALE{}\t\t{}'.format(j, str(bb)))

def access_mem_ratio(llhs):
    print('Access memory ratios')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_mem_ratio()))

def access_bbox_efficiency(llhs):
    print('Access bbox efficiency')
    for (i, ll) in enumerate(llhs):
        print('LOCALE{}\t\t{}'.format(i, ll.gen_access_bbox_efficiency()))

def main():
    mlh, llhs = init_log_handlers()
    if analysis:
        access_bbox_efficiency(llhs)
        access_mem_ratio(llhs)
        rar(llhs)
        # access_bbox(llhs)
        pairwise_access_bbox(llhs)
        pwise_access_efficiency(llhs)
        total_access(llhs)
    if plot:
        do_plot(mlh, llhs)

if __name__=="__main__":
    main()
